JPA 에서 발생하는 N+1 문제란?

- 엔티티 조회시 대상 엔티티(1)외 연관된 엔티티 (N)가 함께 조회되며 다수의 쿼리가 나가는 현상,문제를 의미

### **다양한 환경에서 발생하는 N+1 문제**

- JPA는 @Query 에 직접 작성된 혹은 네이밍 메서드를 분석하여 JPQL을 생성하고 이렇게 생성된 JPQL로 SQL을 만들어 DB에 요청하게 된다.  
이런 동작 특성으로 인해 N+1 문제가 발생하게 된다. JPQL은 직접 쿼리를 요청하는 것과 다르게 동작하기 때문에 특정 엔티티의 하위 엔티티를 조회 하기 위해서는 1. 특정 엔티티 조회 2. 하위 엔티티 조회나뉘어 동작한다.  \
이런 동작 내용은 글로벌 Fetch 전략이 Eager이든 Lazy이든 시점의 차이만 있을 뿐 모두 동일하게 N+1 문제가 발생하게 되는 이유가 된다.  
1. 즉시(Eager)로딩JPQL 쿼리는 쿼리 생성시점에 글로벌 패치 전략을 염두해 두지 않고 쿼리를 생성한다. 처음 생성된 조회 쿼리를 DB에 요청한 이후 글로벌 패치 전략을 확인하게 되고, 이 때 Eager 일 경우 연관관계에 있는 데이터 조회를 위해 다시 쿼리를 날리게 된다 (N+1 발생)추가적으로 즉시 로딩은 N+1문제와 별도로 모든 연관 엔티티를 함께 조회해 오기 때문에 추천하지 않는 옵션이다.
2. 지연(Lazy)로딩JPQL로 생성된 쿼리로 DB에서 데이터 조회(글로벌 Fetch 전략 무시)한다. 이후 글로벌 Fetch 전략이 Lazy로 설정되어 있기 때문에 연관 엔티티들에 대하여 즉시 조회하지 않고 proxy 객체로 대체하며 해당 proxy 객체를 조회 하는 시점에 N+1 발생

### **해결방법**

1. Fetch joinSQL 문법은 아니지만, JPQL에서 성능 최적화를 위해 제공하는 문법 ‘연관된 엔티티 혹은 컬렉션을 한번의 조회로 가져올 수 있도록 제공하는 기능’JPA가 제공하는 페이징 기능 사용 불가 (limit, offset 통한 쿼리가 아닌 in memory로 모두 가져와 application 단에서 처리함으로 OutOfMemory 문제 발생)1:N 관계가 2개인 엔티티(Collection)를 패치 조인하여 사용할 수 없다.  
2. @EntityGraphFetch join과 마찬가지로 연관된 엔티티 혹은 컬렉션을 한번에 조회할 수 있도록 제공하는 어노테이션Spring Data JPA에서 fetch 조인을 어노테이션으로 사용할 수 있도록 만들어준 기능
3. Batch Size 조절Fetch join의 제약사항으로 인해 사용이 불가능 할 경우 batch옵션(글로벌하게 적용시 default_batch_fetch_size 옵션 사용, 독립적으로 사용시 필드 위 @BatchSize 어노테이션 사용)을 통해서 지연로딩으로 발생하는 쿼리를 한번에 모아서 하나의 쿼리로 묶어서 처리 하게 된다.만약 100개의 Review에 대해 연관된 Image 엔티티를 가져올때 N+1 문제가 한다는 가정을 둘때, default_batch_fetch_size를 10으로 설정하면 쿼리 횟수를 단순하게 1/10로 줄일 수 있다.Batch Size는 얼마가 적당할까?Batch Size가 과도하면 한번에 너무 많은 엔티티가 메모리에 로딩되며, Batch Size가 너무 작으면 더 많은 쿼리가 발생하게 된다. 조회할 데이터의 양을 미리 알고 적절하게 설정하는 것이 가장 좋지만 그렇지 않은 경우 100~1000 수준으로 설정하는 경우를 추천하고 있다.페이징과 N+1을 모두 잡고 싶을때는 Lazy + Batch Size 조절이 좋은 방법!Fetch join, Batch Size 모두 in memory에 데이터를 적재하기 때문에 데이터의 양이 너무 많다면 DB에서 가져오는 데이터의 크기를 조절해야 한다 (limit) 이 경우 네이티브 쿼리를 사용할 수 밖에 없다 (feat.김영한)

### **의문점과 해답**

1. Fetch join이 연관된 데이터를 한번에 가져오도록 조회하는 방법이라면 Lazy 로딩을 사용하지 않고 모든 조회에 Eager 로딩을 사용하면 되지 않을까?> Eager 로딩에서도 N+1 문제가 발생한다.(위 내용 참조)