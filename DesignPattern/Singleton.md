### 싱글톤(Singleton)

어플리케이션이 시작되는 시점에 어떤 클래스가에 대해 최초 한번만 메모리를 할당하고, 그 메모리에 인스턴스를 만들어 사용하는 패턴

특징

- 고정된 메모리 영역을 얻기때문에 메모리 낭비를 방지할 수 있다.
  ex) 하나의 인스턴스로 여러 장소에서 돌아가면서 사용하게 된다.
- 싱글톤으로 만들어진 클래스의 인스턴스는 전역이기 때문에 다른 클래스의 인스턴스들이 데이터를 공유하기 쉽다.
- ex) DBCP (DataBaseConnection Pool), 스프링 컨테이너의 Bean 에서 사용된다.

단점

- 싱글톤 패턴은 안티패턴이라고 불린다. 장점에 비해 가져가는 단점이 너무 명확하고 크다.
- 싱글톤으로 설계를 가져갈 경우 싱글톤을 사용하는 곳과 싱글톤 사이에는 의존성이 생기게 된다. 이런 의존성은 시스템 전반에 걸쳐서 생기게 되고 이는 시스템 전체의 결합도를 높여 수정및 단위테스트의 어려움을 생기게 한다.
- 싱글톤의 사용은 전역상태로 접근이 가능하기 때문에 아무 객체나 자유롭게 접근하고 수정하며 공유할 수 있게 된다. 이는 객체지향 프로그래밍에서 지양해야 하는 모델이다.

### Java 싱글톤의 메모리 누수(Memory Leak)
- Java 기반의 애플리케이션은 JVM의 GC를 통해 주기적으로 메모리 관리가 이루어진다.
- 싱글톤패턴도 어느 시점에 데이터를 메모리에 초기화 할 것인지에 따라 종류가 다양하다.
  - Eager initialization( 즉시 초기화 )
    - 싱글톤객체 사용유무와 관계 없이 컴파일 시점에 클래스 로더에 의해 항상 싱글톤 객체가 생성됨
  - Lazy initialization ( 늦은 초기화 )
    - 즉시 초기화와 달리 싱글톤이 사용되는 시점까지 객체 생성을 미루는 방식이며 사용하기 전까지 메모리를 점유하지 않음.
    - 멀티 스레드 환경에서 동시에 getInstance() 호출시 인스턴스가 두 번 생성될 여지가 있음
  - Thread safe zLazy initialization( 스레드 안전한 늦은 초기화 )
    - 늦은 초기화 방식의 단점을 보완하기 위해 synchronized 키워드를 사용하여 처리하는 방식
    - 임계 영역에 lock, unlock 처리로 인해 많은 스레드 동시 사용시 성능 저하 발생 가능성 있음

### 싱글톤과 Spring 싱글톤
- 개발자의 코드 단위로 구현된 싱글톤은 다음과 같은 단점이 있다.
  - 테스트 하기 어렵다.
  - 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.
  - 전역상태의 싱글톤은 객체지향 관점에서 적절하지 못하다.
- Spring을 통해 생성되는 싱글톤은 일반 오브젝트 생성방식이 아닌 프록시 빈 또는 리플렉션을 통해 객체가 생성된다.  
싱글톤 객체 생성을 위해 private 생성자와 static method를 사용하지 않고 평범한 자바 클래스처럼 사용할 수 있다.  
다시 말해 Spring을 이용하면 일반 클래스를 싱글톤처럼 사용할 수 있도록 만들어주는것이다.