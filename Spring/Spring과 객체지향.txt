1. Spring 이란?
- 과거 자바진영 표준 기술 EJB(Enterprise Java Beans)
- 너무 어렵고 복잡하고 느리다.
- 불편하고 복잡한 EJB를 대신하여 Spring이 만들어지게 됨.
- 로드존슨이 만든 3만줄의 코드가 Spring의 시작이 됨.
(사람들이 EJB와 비교하여 Spring을 열광한 이유가 무엇일까?)

- 자바진영의 겨울을 이겨내기 위해 Spring이 나왔지만 여전히 복잡한 설정과정이 존재함.
- 복잡한 Spring Framework의 대부분의 설정을 추상화 시키고, 편리화 시킨 Spring Boot 탄생
- Spring Boot는 내장 Tomcat, 빌드 구성을 위한 Starter 종속성 제공, 다양한 설정 자동화 등 제공
- Spring Framework 과 Spring Boot가 별도인것은 절대 아님.

1.1 스프링의 핵심
- Spring은 자바 언어 기반의 프레임 워크
- 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임 워크
- 스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있도록 도와주는 프레임 워크
- EJB 개발의 단점 중 하나는 EJB에 종속되어 객체지향의 본질이 흐려지게 되는 것

2. 좋은 객체 지향 프로그래밍이란?
- 객체지향 이란? 프로그램을 객체들의 모임으로 바라보고 각각의 객체가 메시지를 주고 받고 데이터를 처리하는 것

2.1 다형성
- 역할과 구현으로 모듈을 구분
역할 - 자동차, 구현 - 아반떼, 테슬라3
각각의 '역할'을 다양하게 '구현'할 수 있는 것
- 객체를 설계할 때 역할과 구현을 명확히 분리
- 역할-> 인터페이스, 구현 -> 인터페이스를 구현한 클래스, 구현 객체

2.2 SOLID
2.2.1 SRP 단일 책임 원칙
- 한 클래스는 하나의 책임만 가져야 한다.
- 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것

2.2.2 OCP 개방-폐쇄 원칙
- 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
- 다형성을 활용, 인터페이스를 구현한 새로운 클래스를 만들어 새로운 기능을 구현
- 개방폐쇄 원칙을 구현하기 위해 DI Container가 만들어지게 됨.

2.2.3 LSP 리스코프 치환 원칙
- 프로그램의 정확성을 깨지 않고 하위 인스턴스를 만들어야한다.
- 엑셀은 앞으로 가야지 뒤로 가면 안됨, 느리더라도 앞으로 가야 한다.

2.2.4 ISP 인터페이스 분리 원칙
- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
ex) 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스 분리
- 인터페이스가 명확해지고, 대체 가능성이 높아진다.

2.2.5 DIP 의존관계 역전 원칙
- 프로그래머는 구현체가 아닌 추상화에 의존해야 한다.

생각 정리
- 객체지향 개발 이란 프로그램을 기능단위의 모듈별로 만들고 각 모듈별로 데이터가 흐르도록 개발하는 것
- 올바른 객체지향을 통해 프로그램을 쉽게 부품을 갈아 끼우듯이 개발 할 수 있다.

- 스프링은 DI와 DI Container 를 통해 다형성, OCP, DIP를 가능하게 지원
- 자바로 OCP, DIP 원칙을 지키며 개발하다보면 Spring Container가 만들어지게 된다.
- 모든 설계에 역할과 구현을 분리하자.
- 프로그램을 언제든지 유연하게 변경할 수 있도록 만드는 것이 좋은 객체 지향 설계다.
- 이상적으로는 모든 설계에 인터페이스를 부여하자.
- 다만 기능을 확장할 가능성이 없다면, 구체 클래스를 직접 사용하고, 향후 꼭 필요할 때 리팩터링을
하여 인터페이스를 도입하는 것도 방법이다.

* Service 와 Service Impl
일부 실무개발에서 Service Interface를 만들고 구현체인 Imple 클래스를 만드는 것을 보았다.
SOLID 법칙의 DIP 원칙에 따라 구현체가 아닌 추상화된 인터페이스에 의존해야 하기 위해 이런 구조가 나온것인데
여러 구현체로 확장가능성이 없음에도 무의식적으로 Interface를 만들어 오히려 가독성에 혼란을 주는 경우가 많다.
구현체가 여러개로 나뉠경우 하나의 인터페이스로 묶는 것은 맞지만 무분별하게 남발하는 것이 아닌
상황에 따라 인터페이스로 구현체를 묶는것이 맞다고 생각된다.